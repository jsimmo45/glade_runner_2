<!DOCTYPE html>
<html>
<head>
  <title>Ryan Simmons' Glade Runner 2</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
    }
    canvas {
      display: block;
      background: white;
      border: 5px solid black;
    }
    #menu, #playerSelect, #endMenu, #pauseMenu, #introMovie {
      display: none;
      text-align: center;
      margin-top: 20px;
    }
    #startButton, #stage1Button, #stage2Button, #stage3Button, #replayMovieButton,
    #player1Button, #player2Button, #player3Button {
      display: block;
      margin: 20px auto;
      padding: 20px;
      font-size: 24px;
    }
    #playerSelect div {
      display: inline-block;
      margin: 0 20px;
    }
    #playerSelect img {
      width: 100px;
      height: 100px;
    }
    #timer {
      text-align: center;
      font-size: 24px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Menus and UI -->
  <div id="menu">
    <img id="titleImage" src="title-screen.png" alt="Title Screen">
    <button id="viewMovieButton">View Intro Movie</button>
    <button id="stage1Button">Stage 1</button>
    <button id="stage2Button">Stage 2</button>
    <button id="stage3Button">Stage 3</button>
  </div>
  <div id="playerSelect">
    <div>
      <img id="ryanRight" src="ryan-right.png" alt="Ryan">
      <button id="player1Button">Ryan</button>
    </div>
    <div>
      <img id="alexRight" src="alex-right.png" alt="Alex">
      <button id="player2Button">Alex</button>
    </div>
    <div>
      <img id="mitchRight" src="mitch-right.png" alt="Mitch">
      <button id="player3Button">Mitch</button>
    </div>
  </div>
  <div id="pauseMenu">
    <button id="pauseButton">Pause</button>
  </div>
  <div id="endMenu">
    <p id="timeTaken"></p>
    <img id="endImage" src="" alt="End Image">
    <button id="restartButton">Restart Game</button>
  </div>
  <div id="introMovie">
    <video id="introVideo" width="800" height="600" controls>
      <source src="intro-movie.mp4" type="video/mp4">
      Your browser does not support the video tag.
    </video>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="timer">Time: 0 seconds</div>

  <!-- Audio Elements -->
  <audio id="titleMusic" loop>
    <source src="Escape_the_Murder_Tree.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="stage1Music" loop>
    <source src="Murder_Tree_Behind_You.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="stage2Music" loop>
    <source src="Murder_Tree_Breakdown.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="stage3Music" loop>
    <source src="stage3-music.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>

  <script>
    console.log("Script loaded");

    /* ---------------- Constants & Helper Functions ---------------- */
    const GAME_STATES = {
      MENU: 'menu',
      PLAYER_SELECT: 'player_select',
      PLAYING: 'playing',
      PAUSED: 'paused',
      GAME_OVER: 'game_over',
      WIN: 'win'
    };

    const STAGES = {
      STAGE1: 1,
      STAGE2: 2,
      STAGE3: 3
    };

    // Simple collision detection (axis-aligned bounding boxes)
    function checkCollision(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    // Returns a Promise that resolves when the image is loaded
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          console.log(`Loaded image: ${src}`);
          resolve(img);
        };
        img.onerror = () => {
          console.error(`Error loading image: ${src}`);
          reject();
        };
        img.src = src;
      });
    }

    /* ---------------- Entity Classes ---------------- */
    class Skier {
      constructor(x, y, width, height, images) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.baseSpeed = 6;
        this.speed = this.baseSpeed;
        this.direction = 'forward';
        this.images = images; // { left, right, forward }
        this.boostActive = false;
        this.boostEndTime = 0;
      }

      update(keys, canvasWidth, canvasHeight) {
        if (keys.ArrowLeft) {
          this.x -= this.speed;
          this.direction = 'left';
        }
        if (keys.ArrowRight) {
          this.x += this.speed;
          this.direction = 'right';
        }
        if (keys.ArrowUp) {
          this.y -= this.speed;
          this.direction = 'forward';
        }
        if (keys.ArrowDown) {
          this.y += this.speed;
          this.direction = 'forward';
        }
        // Constrain within canvas bounds
        this.x = Math.max(0, Math.min(this.x, canvasWidth - this.width));
        this.y = Math.max(0, Math.min(this.y, canvasHeight - this.height));

        // Check boost expiration
        if (this.boostActive && Date.now() > this.boostEndTime) {
          this.speed = this.baseSpeed;
          this.boostActive = false;
          console.log("Speed boost ended");
        }
      }

      draw(ctx) {
        let img;
        if (this.direction === 'left') {
          img = this.images.left;
          ctx.drawImage(img, this.x, this.y, this.width * 1.5, this.height * 1.5);
        } else if (this.direction === 'right') {
          img = this.images.right;
          ctx.drawImage(img, this.x, this.y, this.width * 1.5, this.height * 1.5);
        } else {
          img = this.images.forward;
          ctx.drawImage(img, this.x, this.y, this.width, this.height);
        }
      }

      activateBoost(duration) {
        if (!this.boostActive) {
          this.speed *= 1.33;
          this.boostActive = true;
          this.boostEndTime = Date.now() + duration;
          console.log("Speed boost activated for", duration, "ms");
        }
      }
    }

    class Tree {
      constructor(x, y, width, height, image, canvasHeight) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.image = image;
        this.canvasHeight = canvasHeight;
      }

      update(scrollSpeed) {
        this.y -= scrollSpeed;
        // Recycle the tree when off screen
        if (this.y < -this.height) {
          this.y = this.canvasHeight + Math.random() * this.canvasHeight * 9;
          this.x = Math.random() * (canvas.width - this.width);
        }
      }

      draw(ctx) {
        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
      }
    }

    class Snowman {
      constructor(x, y, width, height, images, canvasHeight) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.images = images; // { intact, hit }
        this.hit = false;
        this.canvasHeight = canvasHeight;
      }

      update(scrollSpeed) {
        this.y -= scrollSpeed;
      }

      draw(ctx) {
        const img = this.hit ? this.images.hit : this.images.intact;
        ctx.drawImage(img, this.x, this.y, this.width, this.height);
      }
    }

    class MurderTree {
      constructor(x, y, width, height, speed, image, canvasWidth, canvasHeight) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.speed = speed;
        this.image = image;
        this.active = false;
        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;
      }

      update(skier, stage) {
        if (!this.active) return;
        // Homing movement: move toward the skier
        let dx = skier.x - this.x;
        let dy = skier.y - this.y;
        let distance = Math.sqrt(dx * dx + dy * dy) || 1;
        this.x += (dx / distance) * this.speed;
        this.y += (dy / distance) * this.speed;
        // Clamp within canvas
        this.x = Math.max(0, Math.min(this.x, this.canvasWidth - this.width));
        this.y = Math.max(0, Math.min(this.y, this.canvasHeight - this.height));
      }

      draw(ctx) {
        if (this.active) {
          ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
        }
      }
    }

    /* ---------------- Main Game Class ---------------- */
    class Game {
      constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.state = GAME_STATES.MENU;
        this.currentStage = STAGES.STAGE1;
        this.pauseTime = 0;
        this.startTime = 0;
        this.elapsedTime = 0;
        this.scrollSpeed = 3; // Background scroll speed
        this.keys = { ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false };
        this.debug = true; // Set to true to enable debugging logs
        this.lastLogTime = -1;

        // Containers for preloaded assets
        this.assets = {
          skier: {},
          tree: null,
          murderTree: null,
          snowman: {}
        };

        // Game objects
        this.skier = null;
        this.trees = [];
        this.snowmen = [];
        this.murderTree = null;
        this.finishLine = { y: -10 * this.canvas.height, width: this.canvas.width, height: 40 };

        // Audio references
        this.audio = {
          title: document.getElementById('titleMusic'),
          stage1: document.getElementById('stage1Music'),
          stage2: document.getElementById('stage2Music'),
          stage3: document.getElementById('stage3Music')
        };

        this.bindInput();
      }

      bindInput() {
        document.addEventListener('keydown', (e) => {
          // Prevent default scrolling with arrow keys
          if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
            e.preventDefault();
          }
          if (this.keys.hasOwnProperty(e.key)) {
            this.keys[e.key] = true;
          } else if (e.key === 'p') {
            this.togglePause();
          }
        });

        document.addEventListener('keyup', (e) => {
          if (this.keys.hasOwnProperty(e.key)) {
            this.keys[e.key] = false;
          }
        });
      }

      async preloadAssets() {
        console.log("Preloading assets...");
        // Preload skier images for each player
        const players = ['ryan', 'alex', 'mitch'];
        for (const name of players) {
          this.assets.skier[name] = {
            left: await loadImage(`${name}-left.png`),
            right: await loadImage(`${name}-right.png`),
            forward: await loadImage(`${name}-forward.png`)
          };
          console.log(`Loaded skier images for ${name}`);
        }
        // Preload tree and murder tree images
        this.assets.tree = await loadImage('tree.png');
        console.log("Loaded tree image");
        this.assets.murderTree = await loadImage('murder-tree.png');
        console.log("Loaded murder tree image");
        // Preload snowman images
        this.assets.snowman = {
          intact: await loadImage('snowman-intact.png'),
          hit: await loadImage('snowman-hit.png')
        };
        console.log("Loaded snowman images");
      }

      initGameObjects(selectedPlayer) {
        console.log("Initializing game objects for player:", selectedPlayer);
        // Initialize the skier using the chosen character images
        this.skier = new Skier(this.canvas.width / 2 - 20, 100, 30, 60, this.assets.skier[selectedPlayer]);

        // Initialize trees
        this.trees = [];
        if (this.currentStage === STAGES.STAGE1) {
          // Create 20 randomly placed trees
          for (let i = 0; i < 20; i++) {
            const treeX = Math.random() * (this.canvas.width - 60);
            const treeY = Math.random() * this.canvas.height * 10 + this.canvas.height;
            this.trees.push(new Tree(treeX, treeY, 60, 80, this.assets.tree, this.canvas.height));
          }
        } else if (this.currentStage === STAGES.STAGE2) {
          // Create rows of trees with a gap
          const rows = 10;
          const cols = Math.floor(this.canvas.width / 60);
          for (let i = 0; i < rows; i++) {
            const gapIndex = Math.floor(Math.random() * (cols - 1));
            for (let j = 0; j < cols; j++) {
              if (j !== gapIndex && j !== gapIndex + 1) {
                this.trees.push(new Tree(j * 60, this.canvas.height * i, 60, 100, this.assets.tree, this.canvas.height));
              }
            }
          }
        } else if (this.currentStage === STAGES.STAGE3) {
          // Create a curving narrow path
          this.trees = [];
          let pathX = this.canvas.width / 2 - 2.5 * this.skier.width;
          const rows = 10;
          const cols = Math.floor(this.canvas.width / 60);
          for (let i = 0; i < rows; i++) {
            const curve = (Math.random() - 0.5) * 2 * this.skier.width;
            pathX = Math.max(0, Math.min(pathX + curve, this.canvas.width - 5 * this.skier.width));
            for (let j = 0; j < cols; j++) {
              if (j * 60 < pathX || j * 60 > pathX + 5 * this.skier.width) {
                this.trees.push(new Tree(j * 60, this.canvas.height * i, 60, 100, this.assets.tree, this.canvas.height));
              }
            }
          }
        }

        // Initialize snowmen
        this.snowmen = [];
        for (let i = 0; i < 3; i++) {
          const snowmanX = Math.random() * (this.canvas.width - 40);
          const snowmanY = Math.random() * this.canvas.height * 10;
          this.snowmen.push(new Snowman(snowmanX, snowmanY, 40, 60, this.assets.snowman, this.canvas.height));
        }

        // Initialize the murder tree
        this.murderTree = new MurderTree(
          Math.random() * (this.canvas.width - 45),
          this.canvas.height + 100,
          45,
          75,
          4.5,
          this.assets.murderTree,
          this.canvas.width,
          this.canvas.height
        );
      }

      togglePause() {
        if (this.state === GAME_STATES.PLAYING) {
          this.state = GAME_STATES.PAUSED;
          this.pauseStart = Date.now();
          console.log("Game paused");
          if (this.currentStage === STAGES.STAGE2) {
            this.audio.stage2.pause();
          } else if (this.currentStage === STAGES.STAGE3) {
            this.audio.stage3.pause();
          } else {
            this.audio.stage1.pause();
          }
        } else if (this.state === GAME_STATES.PAUSED) {
          this.state = GAME_STATES.PLAYING;
          this.pauseTime += Date.now() - this.pauseStart;
          console.log("Game resumed");
          if (this.currentStage === STAGES.STAGE2) {
            this.audio.stage2.play();
          } else if (this.currentStage === STAGES.STAGE3) {
            this.audio.stage3.play();
          } else {
            this.audio.stage1.play();
          }
        }
      }

      update() {
        if (this.state !== GAME_STATES.PLAYING) return;

        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Update skier movement
        this.skier.update(this.keys, this.canvas.width, this.canvas.height);

        // Scroll the finish line
        this.finishLine.y -= this.skier.speed / 2;

        // Update and draw trees
        for (let tree of this.trees) {
          tree.update(this.skier.speed / 2);
          if (checkCollision(this.skier, tree)) {
            console.log("Collision with tree detected");
            this.state = GAME_STATES.GAME_OVER;
            showEndMenu(endImages.tree, this.elapsedTime);
            return;
          }
          tree.draw(this.ctx);
        }

        // Update and draw snowmen; trigger boost on collision
        for (let snowman of this.snowmen) {
          snowman.update(this.skier.speed / 2);
          if (!snowman.hit && checkCollision(this.skier, snowman)) {
            console.log("Collision with snowman detected");
            snowman.hit = true;
            this.skier.activateBoost(3000); // 3-second boost
          }
          snowman.draw(this.ctx);
        }

        // Update elapsed time and display timer
        this.elapsedTime = Math.floor((Date.now() - this.startTime - this.pauseTime) / 1000);
        document.getElementById('timer').textContent = `Time: ${this.elapsedTime} seconds`;

        if (this.debug) {
          // Log once per second
          if (this.elapsedTime > this.lastLogTime) {
            console.log("Update tick: elapsed time =", this.elapsedTime, "state =", this.state);
            this.lastLogTime = this.elapsedTime;
          }
        }

        // Activate murder tree after 10 seconds
        if (this.elapsedTime >= 10 && !this.murderTree.active) {
          this.murderTree.active = true;
          this.murderTree.y = (this.currentStage === STAGES.STAGE3) ? -this.murderTree.height : this.canvas.height;
          console.log("Murder tree activated");
        }

        // Update murder tree and check collision
        if (this.murderTree.active) {
          this.murderTree.update(this.skier, this.currentStage);
          if (checkCollision(this.skier, this.murderTree)) {
            console.log("Collision with murder tree detected");
            this.state = GAME_STATES.GAME_OVER;
            showEndMenu(endImages.murderTree, this.elapsedTime);
            return;
          }
          this.murderTree.draw(this.ctx);
        }

        // Draw the finish line
        this.drawFinishLine();

        // Draw the skier
        this.skier.draw(this.ctx);

        // Win condition: skier passes finish line
        if (this.skier.y < this.finishLine.y + this.finishLine.height) {
          console.log("Win condition reached");
          this.state = GAME_STATES.WIN;
          showEndMenu(endImages.finish, this.elapsedTime);
          return;
        }
      }

      drawFinishLine() {
        for (let i = 0; i < this.finishLine.width / 20; i++) {
          for (let j = 0; j < this.finishLine.height / 20; j++) {
            this.ctx.fillStyle = (i + j) % 2 === 0 ? 'black' : 'white';
            this.ctx.fillRect(i * 20, this.finishLine.y + j * 20, 20, 20);
          }
        }
      }

      render() {
        // Display speed boost notification
        if (this.skier.boostActive) {
          this.ctx.fillStyle = 'black';
          this.ctx.font = '20px Arial';
          this.ctx.fillText('Speed boost!', this.skier.x, this.skier.y - 10);
        }
      }

      gameLoop() {
        if (this.state === GAME_STATES.PLAYING) {
          this.update();
          this.render();
        }
        requestAnimationFrame(this.gameLoop.bind(this));
      }

      startGame(selectedPlayer) {
        console.log("Starting game for player:", selectedPlayer);
        // Switch audio from title to the stage music (add fade transitions if desired)
        this.audio.title.pause();
        if (this.currentStage === STAGES.STAGE2) {
          this.audio.stage2.play();
        } else if (this.currentStage === STAGES.STAGE3) {
          this.audio.stage3.play();
        } else {
          this.audio.stage1.play();
        }
        document.getElementById('menu').style.display = 'none';
        document.getElementById('playerSelect').style.display = 'none';
        document.getElementById('pauseMenu').style.display = 'block';
        this.startTime = Date.now();
        this.state = GAME_STATES.PLAYING;
        this.gameLoop();
      }
    }

    /* ---------------- Global Initialization ---------------- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const endImages = {
      tree: 'hit-tree.jpg',
      murderTree: 'murder-tree-caught.jpg',
      finish: 'stage-finished.jpg'
    };

    const game = new Game(canvas, ctx);

    // Preload all assets, then show the menu
    game.preloadAssets().then(() => {
      console.log("All assets loaded. Displaying menu.");
      document.getElementById('menu').style.display = 'block';
      canvas.style.display = 'none';
      game.audio.title.play();
    }).catch(err => {
      console.error('Error loading assets', err);
    });

    /* ---------------- UI Event Listeners ---------------- */
    document.getElementById('viewMovieButton').addEventListener('click', () => {
      console.log("View Intro Movie button clicked");
      document.getElementById('menu').style.display = 'none';
      document.getElementById('introMovie').style.display = 'block';
      game.audio.title.play();
      document.getElementById('introVideo').play();
    });

    document.getElementById('introVideo').addEventListener('ended', () => {
      console.log("Intro video ended");
      document.getElementById('introMovie').style.display = 'none';
      document.getElementById('menu').style.display = 'block';
    });

    document.getElementById('stage1Button').addEventListener('click', () => {
      console.log("Stage 1 button clicked");
      game.currentStage = STAGES.STAGE1;
      document.getElementById('playerSelect').style.display = 'block';
    });

    document.getElementById('stage2Button').addEventListener('click', () => {
      console.log("Stage 2 button clicked");
      game.currentStage = STAGES.STAGE2;
      document.getElementById('playerSelect').style.display = 'block';
    });

    document.getElementById('stage3Button').addEventListener('click', () => {
      console.log("Stage 3 button clicked");
      game.currentStage = STAGES.STAGE3;
      document.getElementById('playerSelect').style.display = 'block';
    });

    document.getElementById('player1Button').addEventListener('click', () => {
      console.log("Player Ryan selected");
      canvas.style.display = 'block';
      game.initGameObjects('ryan');
      game.startGame('ryan');
    });

    document.getElementById('player2Button').addEventListener('click', () => {
      console.log("Player Alex selected");
      canvas.style.display = 'block';
      game.initGameObjects('alex');
      game.startGame('alex');
    });

    document.getElementById('player3Button').addEventListener('click', () => {
      console.log("Player Mitch selected");
      canvas.style.display = 'block';
      game.initGameObjects('mitch');
      game.startGame('mitch');
    });

    document.getElementById('pauseButton').addEventListener('click', () => {
      console.log("Pause button clicked");
      game.togglePause();
    });

    document.getElementById('restartButton').addEventListener('click', () => {
      console.log("Restart button clicked");
      location.reload();
    });

    // Function to show end screen with appropriate image and time taken
    function showEndMenu(imageSrc, elapsedTime) {
      console.log("Showing end menu:", imageSrc, "Elapsed time:", elapsedTime);
      document.getElementById('endImage').src = imageSrc;
      document.getElementById('timeTaken').textContent = `Time Taken: ${elapsedTime} seconds`;
      document.getElementById('endMenu').style.display = 'block';
      canvas.style.display = 'none';
    }
  </script>
</body>
</html>
